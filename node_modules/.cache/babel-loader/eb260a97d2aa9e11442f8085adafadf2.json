{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n  enumerable: true,\n  get: () => splitAtTopLevelOnly\n});\n\nconst _regex = /*#__PURE__*/_interopRequireWildcard(require(\"../lib/regex\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction* splitAtTopLevelOnly(input, separator) {\n  let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${_regex.escape(separator)}]`, \"g\");\n  let depth = 0;\n  let lastIndex = 0;\n  let found = false;\n  let separatorIndex = 0;\n  let separatorStart = 0;\n  let separatorLength = separator.length; // Find all paren-like things & character\n  // And only split on commas if they're top-level\n\n  for (let match of input.matchAll(SPECIALS)) {\n    let matchesSeparator = match[0] === separator[separatorIndex];\n    let atEndOfSeparator = separatorIndex === separatorLength - 1;\n    let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n    if (match[0] === \"(\") depth++;\n    if (match[0] === \")\") depth--;\n    if (match[0] === \"[\") depth++;\n    if (match[0] === \"]\") depth--;\n    if (match[0] === \"{\") depth++;\n    if (match[0] === \"}\") depth--;\n\n    if (matchesSeparator && depth === 0) {\n      if (separatorStart === 0) {\n        separatorStart = match.index;\n      }\n\n      separatorIndex++;\n    }\n\n    if (matchesFullSeparator && depth === 0) {\n      found = true;\n      yield input.substring(lastIndex, separatorStart);\n      lastIndex = separatorStart + separatorLength;\n    }\n\n    if (separatorIndex === separatorLength) {\n      separatorIndex = 0;\n      separatorStart = 0;\n    }\n  } // Provide the last segment of the string if available\n  // Otherwise the whole string since no `char`s were found\n  // This mirrors the behavior of string.split()\n\n\n  if (found) {\n    yield input.substring(lastIndex);\n  } else {\n    yield input;\n  }\n}","map":{"version":3,"sources":["/Users/mymac/Desktop/material-ui-portfolio/node_modules/tailwindcss/lib/util/splitAtTopLevelOnly.js"],"names":["Object","defineProperty","exports","value","enumerable","get","splitAtTopLevelOnly","_regex","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","input","separator","SPECIALS","RegExp","escape","depth","lastIndex","found","separatorIndex","separatorStart","separatorLength","length","match","matchAll","matchesSeparator","atEndOfSeparator","matchesFullSeparator","index","substring"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"splitAtTopLevelOnly\", {\n    enumerable: true,\n    get: ()=>splitAtTopLevelOnly\n});\nconst _regex = /*#__PURE__*/ _interopRequireWildcard(require(\"../lib/regex\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n        return obj;\n    }\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n        return {\n            default: obj\n        };\n    }\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n        return cache.get(obj);\n    }\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for(var key in obj){\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) {\n                Object.defineProperty(newObj, key, desc);\n            } else {\n                newObj[key] = obj[key];\n            }\n        }\n    }\n    newObj.default = obj;\n    if (cache) {\n        cache.set(obj, newObj);\n    }\n    return newObj;\n}\nfunction* splitAtTopLevelOnly(input, separator) {\n    let SPECIALS = new RegExp(`[(){}\\\\[\\\\]${_regex.escape(separator)}]`, \"g\");\n    let depth = 0;\n    let lastIndex = 0;\n    let found = false;\n    let separatorIndex = 0;\n    let separatorStart = 0;\n    let separatorLength = separator.length;\n    // Find all paren-like things & character\n    // And only split on commas if they're top-level\n    for (let match of input.matchAll(SPECIALS)){\n        let matchesSeparator = match[0] === separator[separatorIndex];\n        let atEndOfSeparator = separatorIndex === separatorLength - 1;\n        let matchesFullSeparator = matchesSeparator && atEndOfSeparator;\n        if (match[0] === \"(\") depth++;\n        if (match[0] === \")\") depth--;\n        if (match[0] === \"[\") depth++;\n        if (match[0] === \"]\") depth--;\n        if (match[0] === \"{\") depth++;\n        if (match[0] === \"}\") depth--;\n        if (matchesSeparator && depth === 0) {\n            if (separatorStart === 0) {\n                separatorStart = match.index;\n            }\n            separatorIndex++;\n        }\n        if (matchesFullSeparator && depth === 0) {\n            found = true;\n            yield input.substring(lastIndex, separatorStart);\n            lastIndex = separatorStart + separatorLength;\n        }\n        if (separatorIndex === separatorLength) {\n            separatorIndex = 0;\n            separatorStart = 0;\n        }\n    }\n    // Provide the last segment of the string if available\n    // Otherwise the whole string since no `char`s were found\n    // This mirrors the behavior of string.split()\n    if (found) {\n        yield input.substring(lastIndex);\n    } else {\n        yield input;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}