{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n\n_export(exports, {\n  parseBoxShadowValue: () => parseBoxShadowValue,\n  formatBoxShadowValue: () => formatBoxShadowValue\n});\n\nconst _splitAtTopLevelOnly = require(\"./splitAtTopLevelOnly\");\n\nlet KEYWORDS = new Set([\"inset\", \"inherit\", \"initial\", \"revert\", \"unset\"]);\nlet SPACE = /\\ +(?![^(]*\\))/g // Similar to the one above, but with spaces instead.\n;\nlet LENGTH = /^-?(\\d+|\\.\\d+)(.*?)$/g;\n\nfunction parseBoxShadowValue(input) {\n  let shadows = Array.from((0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, \",\"));\n  return shadows.map(shadow => {\n    let value = shadow.trim();\n    let result = {\n      raw: value\n    };\n    let parts = value.split(SPACE);\n    let seen = new Set();\n\n    for (let part of parts) {\n      // Reset index, since the regex is stateful.\n      LENGTH.lastIndex = 0; // Keyword\n\n      if (!seen.has(\"KEYWORD\") && KEYWORDS.has(part)) {\n        result.keyword = part;\n        seen.add(\"KEYWORD\");\n      } else if (LENGTH.test(part)) {\n        if (!seen.has(\"X\")) {\n          result.x = part;\n          seen.add(\"X\");\n        } else if (!seen.has(\"Y\")) {\n          result.y = part;\n          seen.add(\"Y\");\n        } else if (!seen.has(\"BLUR\")) {\n          result.blur = part;\n          seen.add(\"BLUR\");\n        } else if (!seen.has(\"SPREAD\")) {\n          result.spread = part;\n          seen.add(\"SPREAD\");\n        }\n      } else {\n        if (!result.color) {\n          result.color = part;\n        } else {\n          if (!result.unknown) result.unknown = [];\n          result.unknown.push(part);\n        }\n      }\n    } // Check if valid\n\n\n    result.valid = result.x !== undefined && result.y !== undefined;\n    return result;\n  });\n}\n\nfunction formatBoxShadowValue(shadows) {\n  return shadows.map(shadow => {\n    if (!shadow.valid) {\n      return shadow.raw;\n    }\n\n    return [shadow.keyword, shadow.x, shadow.y, shadow.blur, shadow.spread, shadow.color].filter(Boolean).join(\" \");\n  }).join(\", \");\n}","map":{"version":3,"sources":["/Users/mymac/Desktop/material-ui-portfolio/node_modules/tailwindcss/lib/util/parseBoxShadowValue.js"],"names":["Object","defineProperty","exports","value","_export","target","all","name","enumerable","get","parseBoxShadowValue","formatBoxShadowValue","_splitAtTopLevelOnly","require","KEYWORDS","Set","SPACE","LENGTH","input","shadows","Array","from","splitAtTopLevelOnly","map","shadow","trim","result","raw","parts","split","seen","part","lastIndex","has","keyword","add","test","x","y","blur","spread","color","unknown","push","valid","undefined","filter","Boolean","join"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    parseBoxShadowValue: ()=>parseBoxShadowValue,\n    formatBoxShadowValue: ()=>formatBoxShadowValue\n});\nconst _splitAtTopLevelOnly = require(\"./splitAtTopLevelOnly\");\nlet KEYWORDS = new Set([\n    \"inset\",\n    \"inherit\",\n    \"initial\",\n    \"revert\",\n    \"unset\"\n]);\nlet SPACE = /\\ +(?![^(]*\\))/g // Similar to the one above, but with spaces instead.\n;\nlet LENGTH = /^-?(\\d+|\\.\\d+)(.*?)$/g;\nfunction parseBoxShadowValue(input) {\n    let shadows = Array.from((0, _splitAtTopLevelOnly.splitAtTopLevelOnly)(input, \",\"));\n    return shadows.map((shadow)=>{\n        let value = shadow.trim();\n        let result = {\n            raw: value\n        };\n        let parts = value.split(SPACE);\n        let seen = new Set();\n        for (let part of parts){\n            // Reset index, since the regex is stateful.\n            LENGTH.lastIndex = 0;\n            // Keyword\n            if (!seen.has(\"KEYWORD\") && KEYWORDS.has(part)) {\n                result.keyword = part;\n                seen.add(\"KEYWORD\");\n            } else if (LENGTH.test(part)) {\n                if (!seen.has(\"X\")) {\n                    result.x = part;\n                    seen.add(\"X\");\n                } else if (!seen.has(\"Y\")) {\n                    result.y = part;\n                    seen.add(\"Y\");\n                } else if (!seen.has(\"BLUR\")) {\n                    result.blur = part;\n                    seen.add(\"BLUR\");\n                } else if (!seen.has(\"SPREAD\")) {\n                    result.spread = part;\n                    seen.add(\"SPREAD\");\n                }\n            } else {\n                if (!result.color) {\n                    result.color = part;\n                } else {\n                    if (!result.unknown) result.unknown = [];\n                    result.unknown.push(part);\n                }\n            }\n        }\n        // Check if valid\n        result.valid = result.x !== undefined && result.y !== undefined;\n        return result;\n    });\n}\nfunction formatBoxShadowValue(shadows) {\n    return shadows.map((shadow)=>{\n        if (!shadow.valid) {\n            return shadow.raw;\n        }\n        return [\n            shadow.keyword,\n            shadow.x,\n            shadow.y,\n            shadow.blur,\n            shadow.spread,\n            shadow.color\n        ].filter(Boolean).join(\" \");\n    }).join(\", \");\n}\n"]},"metadata":{},"sourceType":"script"}